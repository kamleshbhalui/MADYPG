layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct _vertices
{
  // vec4 x;
  // vec4 other;
  // NOTE: apparently structural alignment takes biggest element of structure. eg. vec3 and vec4 will be aligned like 2 vec4 !
  // either make sure that buffers are aligned nicely like that (if using vec4 for pos then make sure its a multiple of 4x4byte)
  // or use separate floats which make alignent 4byte
  float x,y,z,t,u,v,r;
};
layout(std430, binding = 0) buffer _vertexBuffer
{
  _vertices data[];
} buf_Xws;


struct _bary {
  float a, b, c;
  int id;
};
layout(std430, binding = 1) readonly buffer _baryBuffer
{
  _bary data[];
} buf_B;

struct _alignedvec3 {
  float x,y,z;
};
struct _aligneduvec3 {
  uint x,y,z;
};

layout(std430, binding = 2) readonly buffer _normalBuffer
{
  _alignedvec3 data[];
} buf_NNv;


layout(std430, binding = 3) readonly buffer _meshXBuffer
{
  // vec3 data[];
  _alignedvec3 data[];
} buf_meshX;

layout(std430, binding = 4) readonly buffer _meshFBuffer
{
  _aligneduvec3 data[];
} buf_meshF;

layout(std430, binding = 5) readonly buffer _meshFmsBuffer
{
  _aligneduvec3 data[];
} buf_meshFms;

uniform bool apply = true;
uniform bool flat_normals = false;


// TODO use memory qualifiers: readonly, writeonly, restrict? coherent?

void main()
{
  uint vix = gl_GlobalInvocationID.x;

  _bary abci =  buf_B.data[vix];
  int tri = abci.id;
  if(tri >= 0) {

    _vertices V = buf_Xws.data[vix];

    if (!apply) { // TODO MOVE OUTSIDE OF COMPUTE()
      // TODO

      // buf_Xws.data[vix].x = abci.a;
      // buf_Xws.data[vix].y = abci.b;
      // buf_Xws.data[vix].z = abci.c; 
      return;
    }

    float h = V.z;

    vec3 n;
    if (flat_normals) {
      _alignedvec3 n0 = buf_NNv.data[tri];
      n = vec3(n0.x, n0.y, n0.z);
    } else {
      _aligneduvec3 ms_ixs = buf_meshFms.data[tri];

      _alignedvec3 n0 = buf_NNv.data[ms_ixs.x];
      _alignedvec3 n1 = buf_NNv.data[ms_ixs.y];
      _alignedvec3 n2 = buf_NNv.data[ms_ixs.z];
      n = vec3(
        n0.x * abci.a + n1.x * abci.b + n2.x * abci.c,
        n0.y * abci.a + n1.y * abci.b + n2.y * abci.c,
        n0.z * abci.a + n1.z * abci.b + n2.z * abci.c
      );
      // n = buf_NNv.data[ms_ixs.x] * abci.a + buf_NNv.data[ms_ixs.y] * abci.b + buf_NNv.data[ms_ixs.z] * abci.c;
      n = normalize(n);
    }
    _aligneduvec3 ws_ixs = buf_meshF.data[tri];

    _alignedvec3 x0 = buf_meshX.data[ws_ixs.x];
    _alignedvec3 x1 = buf_meshX.data[ws_ixs.y];
    _alignedvec3 x2 = buf_meshX.data[ws_ixs.z];
    vec3 phi = vec3(
    x0.x * abci.a + x1.x * abci.b + x2.x * abci.c,
    x0.y * abci.a + x1.y * abci.b + x2.y * abci.c,
    x0.z * abci.a + x1.z * abci.b + x2.z * abci.c
    );
    // vec3 phi = buf_meshX.data[ws_ixs.x] * abci.a + buf_meshX.data[ws_ixs.y] * abci.b + buf_meshX.data[ws_ixs.z] * abci.c;
    // vec3 phi = vec3(
    //   buf_meshX.data[vix % 5000].x,
    //   buf_meshX.data[vix % 5000].y,
    //   buf_meshX.data[vix % 5000].z
    // );
    // vec3 phi = buf_meshX.data[vix % 5000].x;
    phi += h * n;

    // phi = buf_meshX.data[0];
    V.x = phi.x;
    V.y = phi.y;
    V.z = phi.z;

    buf_Xws.data[vix] = V;
  }
}
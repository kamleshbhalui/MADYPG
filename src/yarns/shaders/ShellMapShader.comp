// NOTE: SHELLMAPSHADER_WRKGRPSIZE defined during compilation
layout(local_size_x = SHELLMAPSHADER_WRKGRPSIZE, local_size_y = 1, local_size_z = 1) in;

struct _vertices
{
  // vec4 x;
  // vec4 other;
  // NOTE: apparently structural alignment takes biggest element of structure. eg. vec3 and vec4 will be aligned like 2 vec4 !
  // either make sure that buffers are aligned nicely like that (if using vec4 for pos then make sure its a multiple of 4x4byte)
  // or use separate floats which make alignent 4byte
  float x,y,z,t,u,v,r;
};
layout(std430, binding = 0) buffer _vertexBuffer
{
  _vertices data[];
} buf_Xws;


struct _bary {
  float a, b, c;
  int id;
};
layout(std430, binding = 1) readonly buffer _baryBuffer
{
  _bary data[];
// } buf_B;
} buf_B0;

struct _alignedvec3 {
  float x,y,z;
};
struct _aligneduvec3 {
  uint x,y,z;
};

layout(std430, binding = 2) readonly buffer _normalBuffer
{
  _alignedvec3 data[];
} buf_NNv;


layout(std430, binding = 3) readonly buffer _meshXBuffer
{
  // vec3 data[];
  _alignedvec3 data[];
} buf_meshX;

layout(std430, binding = 4) readonly buffer _meshFBuffer
{
  _aligneduvec3 data[];
} buf_meshF;

layout(std430, binding = 5) readonly buffer _meshFmsBuffer
{
  _aligneduvec3 data[];
} buf_meshFms;

struct _DiU {
  vec2 Dcol0, Dcol1, U0;
};
layout(std430, binding = 6) readonly buffer _meshDiUBuffer
{
  _DiU data[];
} buf_meshDinvU;

uniform bool apply = true;
uniform bool flat_normals = false;
uniform uint num_vertices;


// TODO use memory qualifiers: readonly, writeonly, restrict? coherent?

void main()
{
  uint vix = gl_GlobalInvocationID.x;
  if (vix >= num_vertices) // incase of num_vertices incompatible with workgroup size
    return;

  // _bary abci =  buf_B.data[vix];
  // int tri = abci.id;
  int tri = buf_B0.data[vix].id;

  if(tri >= 0) {

    _vertices V = buf_Xws.data[vix];

    if (!apply) { // TODO MOVE OUTSIDE OF COMPUTE()
      // TODO

      // buf_Xws.data[vix].x = abci.a;
      // buf_Xws.data[vix].y = abci.b;
      // buf_Xws.data[vix].z = abci.c; 
      return;
    }

    vec3 abc;
    { // barycentrics
      vec2 p = vec2(V.x, V.y);
      _DiU DiU = buf_meshDinvU.data[tri];
      mat2 Dinv = mat2(DiU.Dcol0, DiU.Dcol1);
      abc.yz = Dinv * (p - DiU.U0);
      abc.x = 1 - abc.y - abc.z;
    }


    float h = V.z;

    vec3 n;
    if (flat_normals) {
      _alignedvec3 n0 = buf_NNv.data[tri];
      n = vec3(n0.x, n0.y, n0.z);
    } else {
      _aligneduvec3 ms_ixs = buf_meshFms.data[tri];

      _alignedvec3 n0 = buf_NNv.data[ms_ixs.x];
      _alignedvec3 n1 = buf_NNv.data[ms_ixs.y];
      _alignedvec3 n2 = buf_NNv.data[ms_ixs.z];
      n = vec3(
        // n0.x * abci.a + n1.x * abci.b + n2.x * abci.c,
        // n0.y * abci.a + n1.y * abci.b + n2.y * abci.c,
        // n0.z * abci.a + n1.z * abci.b + n2.z * abci.c
        n0.x * abc.x + n1.x * abc.y + n2.x * abc.z,
        n0.y * abc.x + n1.y * abc.y + n2.y * abc.z,
        n0.z * abc.x + n1.z * abc.y + n2.z * abc.z
      );
      // n = buf_NNv.data[ms_ixs.x] * abci.a + buf_NNv.data[ms_ixs.y] * abci.b + buf_NNv.data[ms_ixs.z] * abci.c;
      n = normalize(n);
    }
    _aligneduvec3 ws_ixs = buf_meshF.data[tri];

    _alignedvec3 x0 = buf_meshX.data[ws_ixs.x];
    _alignedvec3 x1 = buf_meshX.data[ws_ixs.y];
    _alignedvec3 x2 = buf_meshX.data[ws_ixs.z];
    vec3 phi = vec3(
    // x0.x * abci.a + x1.x * abci.b + x2.x * abci.c,
    // x0.y * abci.a + x1.y * abci.b + x2.y * abci.c,
    // x0.z * abci.a + x1.z * abci.b + x2.z * abci.c
    x0.x * abc.x + x1.x * abc.y + x2.x * abc.z,
    x0.y * abc.x + x1.y * abc.y + x2.y * abc.z,
    x0.z * abc.x + x1.z * abc.y + x2.z * abc.z
    );
    // vec3 phi = buf_meshX.data[ws_ixs.x] * abci.a + buf_meshX.data[ws_ixs.y] * abci.b + buf_meshX.data[ws_ixs.z] * abci.c;
    // vec3 phi = vec3(
    //   buf_meshX.data[vix % 5000].x,
    //   buf_meshX.data[vix % 5000].y,
    //   buf_meshX.data[vix % 5000].z
    // );
    // vec3 phi = buf_meshX.data[vix % 5000].x;
    phi += h * n;

    // phi = buf_meshX.data[0];
    V.x = phi.x + 0.2;
    V.y = phi.y;
    V.z = phi.z;

    buf_Xws.data[vix] = V;
  }
}